<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbit Jump Multiplayer</title>
    <style>
        @import ur[](https://fonts.googleapis.com/css?family=Open+Sans:600);
        .webgl {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            outline: none;
            background-color: #000000;
            cursor: move;
            /* fallback if grab cursor is unsupported */
            cursor: grabbing;
            cursor: -moz-grabbing;
            cursor: -webkit-grabbing;
        }
        #credits {
            position: absolute;
            width: 100%;
            margin: auto;
            bottom: 0;
            margin-bottom: 20px;
            font-family: "Open Sans", sans-serif;
            color: #544027;
            font-size: 0.7em;
            text-transform: uppercase;
            text-align: center;
        }
        #credits a {
            color: #7beeff;
        }
        #credits a:hover {
            color: #ff3434;
        }
        #instructions{
            position: absolute;
            width: 100%;
            margin: auto;
            bottom: 60px;
            font-family: "Open Sans", sans-serif;
            color: #ff3434;
            font-size: 0.7em;
            text-transform: uppercase;
            text-align: center;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: "Open Sans", sans-serif;
            color: #7beeff;
            font-size: 1.2em;
            font-weight: 600;
            text-transform: uppercase;
            z-index: 10;
        }
        #menu, #countdown {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-family: "Open Sans", sans-serif;
            color: #7beeff;
        }
        #countdown {
            display: none;
        }
        #countText {
            font-size: 5em;
            font-weight: 600;
            text-transform: uppercase;
        }
        #menu h1 {
            font-size: 2em;
            margin-bottom: 20px;
        }
        button {
            background: #ff3434;
            color: #7beeff;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            margin: 10px;
            cursor: pointer;
            font-family: "Open Sans", sans-serif;
        }
    </style>
</head>
<body>
    <canvas class="webgl"></canvas>
    <audio id="jumpSound" src="music/salto.wav" preload="auto"></audio>
    <audio id="carrotSound" src="music/sound5 (1).wav" preload="auto"></audio>
    <audio id="backgroundMusic" src="music/juego-play.mp3" preload="auto" loop></audio>
    <div id="menu">
        <h1>Elige Jugador</h1>
        <button id="player1">Jugador 1</button>
        <button id="player2">Jugador 2</button>
    </div>
    <div id="countdown">
        <h1 id="countText">3</h1>
    </div>
    <div id="score">Zanahorias: 0 | Nivel: 1</div>
    <div id="instructions"> - Presiona para saltar - Mueve el mouse para dirigir al conejo - Â¡Colecciona zanahorias para subir de nivel y aumentar la dificultad! </div>
    <div id="credits">
        <p></p>
    </div>

    <script type="x-shader/x-vertex" id="reflectorVertexShader">
        uniform mat4 textureMatrix;
        varying vec4 vUvReflection;
        varying vec2 vUv;
        #include <common>
        #include <shadowmap_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        void main() {
            #include <beginnormal_vertex>
            #include <defaultnormal_vertex>
            #include <begin_vertex>
            vUvReflection = textureMatrix * vec4( position, 1.0 );
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            #include <logdepthbuf_vertex>
            #include <worldpos_vertex>
            #include <shadowmap_vertex>
        }
    </script>
     
    <script type="x-shader/x-fragment" id="reflectorFragmentShader">
        uniform vec3 color;
        uniform sampler2D tDiffuse;
        uniform sampler2D tScratches;
        varying vec4 vUvReflection;
        varying vec2 vUv;
         
        #include <common>
        #include <packing>
        #include <lights_pars_begin>
        #include <shadowmap_pars_fragment>
        #include <shadowmask_pars_fragment>
        #include <logdepthbuf_pars_fragment>
         
        vec4 blur9(sampler2D image, vec4 uv, vec2 resolution, vec2 direction) {
            vec4 color = vec4(0.0);
            vec2 off1 = vec2(1.3846153846) * direction;
            vec2 off2 = vec2(3.2307692308) * direction;
            color += texture2DProj(image, uv) * 0.2270270270;
            color += texture2DProj(image, uv + vec4(off1 / resolution, off1 / resolution)) * 0.3162162162;
            color += texture2DProj(image, uv - vec4(off1 / resolution, off1 / resolution)) * 0.3162162162;
            color += texture2DProj(image, uv + vec4(off2 / resolution, off2 / resolution)) * 0.0702702703;
            color += texture2DProj(image, uv - vec4(off2 / resolution, off2 / resolution)) * 0.0702702703;
            return color;
        }
        float blendOverlay( float base, float blend ) {
            return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
        }
        vec3 blendOverlay( vec3 base, vec3 blend ) {
            return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
        }
        void main() {
            #include <logdepthbuf_fragment>
                   
                   
            vec4 displacement = vec4( sin(vUvReflection.y * 3.) * .05, sin(vUvReflection.x * 3.) * .05, 0.0, 0.0);
            vec2 resolution = vec2(30., 30.);
            vec4 base = blur9( tDiffuse, vUvReflection + displacement, resolution, vec2(1., 0.) ) * .25;
            base += blur9( tDiffuse, vUvReflection + displacement, resolution, vec2(-1., 0.) ) * .25;
            base += blur9( tDiffuse, vUvReflection + displacement, resolution, vec2(0, 1.) ) * .25;
            base += blur9( tDiffuse, vUvReflection + displacement, resolution, vec2(0, -1.) ) * .25;
       
            vec4 scratchesCol = texture2D( tScratches, vUv);
       
            vec3 col = mix(color, base.rgb, .5);
            col.rgb += scratchesCol.r * .02;
            col.gb -= scratchesCol.g * .01;
            col.gb -= (1.0 - getShadowMask() ) * .015;
       
            gl_FragColor = vec4(col, 1.0);
            #include <tonemapping_fragment>
            #include <colorspace_fragment>
        }
    </script>
    <script type="x-shader/x-vertex" id="simulationVertexShader">
        precision highp float;
        uniform float time;
        varying vec2 vUv;
        void main() {
            vUv = uv;
            vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
            gl_Position = projectionMatrix * modelViewPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="simulationFragmentShader">
        // fragment shader
        precision highp float;
        uniform sampler2D inputTexture;
        uniform vec2 blade1PosOld;
        uniform vec2 blade1PosNew;
        uniform float strength;
        uniform float time;
        varying vec2 vUv;
        float lineSegment(vec2 p, vec2 a, vec2 b, float thickness) {
            vec2 pa = p - a;
            vec2 ba = b - a;
            float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
            float idk = length(pa - ba*h);
            return smoothstep(thickness, .2 * thickness, idk);
        }
        void main(void) {
            vec4 prevTexture = texture2D(inputTexture, vUv);
            vec3 col = prevTexture.rgb * .999;
            if (strength>0.){
                float space = .001;
                float crease = .001;
                float thickness = .001 + strength * .001;
                float leftRed = lineSegment(vUv + space, blade1PosOld, blade1PosNew, thickness);
                float leftGreen = lineSegment(vUv + space + crease, blade1PosOld, blade1PosNew, thickness);
                float rightRed = lineSegment(vUv - space - crease, blade1PosOld, blade1PosNew, thickness);
                float rightGreen = lineSegment(vUv - space, blade1PosOld, blade1PosNew, thickness);
                col.r += ( leftRed + rightRed ) * strength * 3.0;
                col.g += ( leftGreen + rightGreen) * strength * 3.0;
                col.r = clamp(col.r, .0, 1.0);
                col.g = clamp(col.g, .0, 1.0);
            }
            gl_FragColor = vec4(col, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="outlineFragmentShader">
        uniform vec3 color;
        void main(void) {
            gl_FragColor = vec4( color, 1.0);
        }
    </script>
    <script type="x-shader/x-vertex" id="outlineVertexShader">
        uniform float size;
        uniform float time;
        void main() {
            vec3 transformed = position + normal * size * (1.0 + abs( sin ( position.y * time * .02 ) * 2.0 ));
            vec4 modelViewPosition = modelViewMatrix * vec4(transformed, 1.0);
            gl_Position = projectionMatrix * modelViewPosition;
        }
    </script>

    <script type="module">
        import * as THREE from "https://esm.sh/three@0.156.1";
        import { OrbitControls } from "https://esm.sh/three@0.156.1/examples/jsm/controls/OrbitControls.js";
        import { GLTFLoader } from "https://esm.sh/three@0.156.1/examples/jsm/loaders/GLTFLoader";
        import gsap from "https://esm.sh/gsap";
        import { Reflector } from "https://esm.sh/three@0.156.1/examples/jsm/objects/Reflector";
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, get } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-database.js";

        const firebaseConfig = {
          apiKey: "AIzaSyCmwOvmF0dyDsWgzns1RfNUXb_kXMa_iGM",
          authDomain: "database-juego1.firebaseapp.com",
          databaseURL: "https://database-juego1-default-rtdb.firebaseio.com",
          projectId: "database-juego1",
          storageBucket: "database-juego1.firebasestorage.app",
          messagingSenderId: "20627022529",
          appId: "1:20627022529:web:e2c2dace811bd4d002aa40",
          measurementId: "G-N00ZC1JMGR"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        document.addEventListener("DOMContentLoaded", () => new App());

        class App {
            constructor() {
                this.db = db;
                this.winWidth = window.innerWidth;
                this.winHeight = window.innerHeight;
                this.gltfFile = "https://assets.codepen.io/264161/rabbit6.glb";
                this.score = 0;
                this.level = 1;
                this.gameState = 'menu';
                this.playerId = null;
                this.rabbit1 = null;
                this.rabbit2 = null;
                this.rabbit = null;
                this.otherRabbit = null;
                this.rabbitBody = null;
                this.earLeft = null;
                this.earRight = null;
                this.scoreElement = document.getElementById('score');
                this.jumpSound = document.getElementById('jumpSound');
                this.carrotSound = document.getElementById('carrotSound');
                this.backgroundMusic = document.getElementById('backgroundMusic');
                this.menu = document.getElementById('menu');
                this.countdown = document.getElementById('countdown');
                this.countText = document.getElementById('countText');
                this.isUncontrolled = false;
                this.uncontrolledEndTime = 0;
                this.nextSkullSpawn = Date.now() / 1000 + 2;
                this.isExploding = false;
                this.lastSync = 0;
                this.initGame();
                this.setupListeners();
                document.getElementById('player1').addEventListener('click', () => this.selectPlayer(1));
                document.getElementById('player2').addEventListener('click', () => this.selectPlayer(2));
                this.loadAssets();
            }

            initGame() {
                set(ref(this.db, 'game/players'), {
                    1: {chosen: false, position:{x:0,y:0,z:0}, rotation:{x:0,y:0,z:0}, score:0, level:1},
                    2: {chosen: false, position:{x:0,y:0,z:0}, rotation:{x:0,y:0,z:0}, score:0, level:1}
                });
                set(ref(this.db, 'game/shared'), {
                    carrot: {position:{x:0,y:0,z:0}, visible: false, targetY:0},
                    skull: {position:{x:0,y:0,z:0}, visible: false, targetY:0},
                    nextSkullSpawn: Date.now() / 1000 + 2,
                    started: false,
                    countdown: null
                });
            }

            setupListeners() {
                // Listen for player choices to hide buttons
                onValue(ref(this.db, 'game/players'), (snap) => {
                    const data = snap.val() || {};
                    const p1Btn = document.getElementById('player1');
                    const p2Btn = document.getElementById('player2');
                    if (data[1]?.chosen) p1Btn.style.display = 'none';
                    if (data[2]?.chosen) p2Btn.style.display = 'none';
                });

                // Listen for countdown
                onValue(ref(this.db, 'game/shared/countdown'), (snap) => {
                    const val = snap.val();
                    if (val !== null) {
                        this.menu.style.display = 'none';
                        this.countdown.style.display = 'flex';
                        if (val > 0) {
                            this.countText.textContent = val;
                        } else if (val === 0) {
                            this.countText.textContent = 'Â¡GO!';
                            setTimeout(() => {
                                this.countdown.style.display = 'none';
                                if (this.playerId) this.startGame();
                            }, 1000);
                        }
                    }
                });

                // Listen for nextSkullSpawn
                onValue(ref(this.db, 'game/shared/nextSkullSpawn'), (snap) => {
                    this.nextSkullSpawn = snap.val() || 0;
                });
            }

            selectPlayer(player) {
                this.playerId = player;
                set(ref(this.db, `game/players/${player}/chosen`), true);
                get(ref(this.db, 'game')).then((snap) => {
                    const data = snap.val();
                    const p1 = data.players?.[1]?.chosen || false;
                    const p2 = data.players?.[2]?.chosen || false;
                    const shared = data.shared || {};
                    if (p1 && p2 && !shared.started) {
                        this.startSharedCountdown();
                    } else if (p1 && p2) {
                        this.startGame();
                    }
                });
            }

            startSharedCountdown() {
                this.countdown.style.display = 'flex';
                set(ref(this.db, 'game/shared/countdown'), 3);
                this.countText.textContent = '3';
                setTimeout(() => {
                    set(ref(this.db, 'game/shared/countdown'), 2);
                    this.countText.textContent = '2';
                    setTimeout(() => {
                        set(ref(this.db, 'game/shared/countdown'), 1);
                        this.countText.textContent = '1';
                        setTimeout(() => {
                            set(ref(this.db, 'game/shared/countdown'), 0);
                            this.countText.textContent = 'Â¡GO!';
                            setTimeout(() => {
                                set(ref(this.db, 'game/shared/started'), true);
                                set(ref(this.db, 'game/shared/countdown'), null);
                                this.countdown.style.display = 'none';
                                this.spawnCarrot();
                                this.startGame();
                            }, 1000);
                        }, 1000);
                    }, 1000);
                }, 1000);
            }

            startGame() {
                this.gameState = 'playing';
                if (this.baseGltf) {
                    this.setUpScene();
                }
                this.backgroundMusic.play().catch(e => console.log('Error al reproducir mÃºsica:', e));
            }

            loadAssets() {
                const loaderModel = new GLTFLoader();
                loaderModel.load(this.gltfFile, (gltf) => {
                    this.baseGltf = gltf;
                    if (this.gameState === 'playing') {
                        this.setUpScene();
                    }
                });
            }

            updateScore() {
                this.scoreElement.textContent = `Zanahorias: ${this.score} | Nivel: ${this.level}`;
            }

            applyMaterials(rabbit, prim, sec) {
                const body = rabbit.getObjectByName("body");
                if (body) body.material = prim;
                const earRight = rabbit.getObjectByName("earRight");
                if (earRight) earRight.material = prim;
                const earLeft = rabbit.getObjectByName("earLeft");
                if (earLeft) earLeft.material = prim;
                const tail = rabbit.getObjectByName("tail");
                if (tail) tail.material = prim;
                const footLeft = rabbit.getObjectByName("footLeft");
                if (footLeft) footLeft.material = sec;
                const footRight = rabbit.getObjectByName("footRight");
                if (footRight) footRight.material = sec;
                const eyeLeft = rabbit.getObjectByName("eyeLeft");
                if (eyeLeft) eyeLeft.material = sec;
                const eyeRight = rabbit.getObjectByName("eyeRight");
                if (eyeRight) eyeRight.material = sec;
            }

            addOutline(origin) {
                let outline = origin.clone();
                outline.children = [];
                outline.position.set(0, 0, 0);
                outline.rotation.x = 0;
                outline.rotation.y = 0;
                outline.rotation.z = 0;
                outline.scale.set(1, 1, 1);
                outline.material = this.outlineMat;
                origin.add(outline);
                return outline;
            }

            addOutlines(rabbit) {
                const body = rabbit.getObjectByName("body");
                if (body) this.addOutline(body);
                const earRight = rabbit.getObjectByName("earRight");
                if (earRight) this.addOutline(earRight);
                const earLeft = rabbit.getObjectByName("earLeft");
                if (earLeft) this.addOutline(earLeft);
                const tail = rabbit.getObjectByName("tail");
                if (tail) this.addOutline(tail);
            }

            setUpScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.bgrColor = 0x332e2e;
                this.fog = new THREE.Fog(this.bgrColor, 13, 20);
                this.scene.fog = this.fog;
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    this.winWidth / this.winHeight,
                    1,
                    100
                );
                this.camera.position.set(0, 4, 8);
                this.camera.lookAt(new THREE.Vector3());
                this.scene.add(this.camera);
                // Hero params
                this.heroAngularSpeed = 0;
                this.heroOldRot = 0;
                this.heroDistance = 0;
                this.heroOldUVPos = new THREE.Vector2(0.5, 0.5);
                this.heroNewUVPos = new THREE.Vector2(0.5, 0.5);
                this.heroSpeed = new THREE.Vector2(0, 0);
                this.heroAcc = new THREE.Vector2(0, 0);
                this.targetHeroUVPos = new THREE.Vector2(0.5, 0.5);
                this.targetHeroAbsMousePos = new THREE.Vector2(0, 0);
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.isJumping = this.isLanding = false;
                this.jumpParams = { jumpProgress: 0, landProgress: 0 };
                // Clock
                this.clock = new THREE.Clock();
                this.time = 0;
                this.deltaTime = 0;
               
                // Core
                this.createRenderer();
                this.createSim();
                //this.createControls();
                this.createListeners();
                // Environment
                this.floorSize = 30;
                this.createMaterials();
                this.processModels();
                this.createFloor();
                this.createLine();
                this.createLight();
                this.createParticles();
                this.updateScore();
                // Set up Firebase listeners for shared objects and other player
                this.setupRealtimeListeners();
                // Render loop
                this.draw();
            }

            processModels() {
                const gltf = this.baseGltf;
                // Player 1
                this.rabbit1 = gltf.scene.getObjectByName("Rabbit").clone();
                this.applyMaterials(this.rabbit1, this.primMat1, this.secMat1);
                this.addOutlines(this.rabbit1);
                this.rabbit1.traverse((object) => {
                    if (object.isMesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
                this.scene.add(this.rabbit1);

                // Player 2
                this.rabbit2 = gltf.scene.getObjectByName("Rabbit").clone();
                this.applyMaterials(this.rabbit2, this.primMat2, this.secMat2);
                this.addOutlines(this.rabbit2);
                this.rabbit2.traverse((object) => {
                    if (object.isMesh) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                    }
                });
                this.scene.add(this.rabbit2);

                // Set controlled rabbit
                this.rabbit = this.playerId === 1 ? this.rabbit1 : this.rabbit2;
                this.otherRabbit = this.playerId === 1 ? this.rabbit2 : this.rabbit1;
                this.rabbitBody = this.rabbit.getObjectByName("body");
                this.earLeft = this.rabbit.getObjectByName("earLeft");
                this.earRight = this.rabbit.getObjectByName("earRight");

                // Carrot
                this.carrot = gltf.scene.getObjectByName("carrot").clone();
                this.carrot.traverse((object) => {
                    if (object.isMesh) {
                        object.material = this.bonusMat;
                        object.castShadow = true;
                    }
                });
                this.addOutline(this.carrot);
                this.carrot.rotation.z = 0.2;
                this.carrot.rotation.x = 0.2;
                this.scene.add(this.carrot);
                this.carrot.visible = false;

                // Skull
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.font = '256px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ð', 128, 128);
                const texture = new THREE.CanvasTexture(canvas);
                const skullGeometry = new THREE.PlaneGeometry(0.6, 0.6);
                const skullMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true,
                    side: THREE.DoubleSide 
                });
                this.skull = new THREE.Mesh(skullGeometry, skullMaterial);
                this.skull.visible = false;
                this.scene.add(this.skull);
            }

            setupRealtimeListeners() {
                const otherId = 3 - this.playerId;
                // Listen for other player
                onValue(ref(this.db, `game/players/${otherId}`), (snap) => {
                    const data = snap.val();
                    if (data && this.otherRabbit) {
                        this.otherRabbit.position.set(data.position?.x || 0, data.position?.y || 0, data.position?.z || 0);
                        this.otherRabbit.rotation.set(data.rotation?.x || 0, data.rotation?.y || 0, data.rotation?.z || 0);
                    }
                });

                // Listen for carrot
                onValue(ref(this.db, 'game/shared/carrot'), (snap) => {
                    const data = snap.val();
                    if (data) {
                        this.carrot.position.set(data.position?.x || 0, data.position?.y || 0, data.position?.z || 0);
                        this.carrot.visible = data.visible || false;
                        if (data.visible && data.position?.y === -1 && data.targetY !== undefined) {
                            this.carrot.scale.set(0, 0, 0);
                            gsap.to(this.carrot.scale, { duration: 1.5, ease: "elastic.out", x: 1, y: 1, z: 1 });
                            gsap.to(this.carrot.position, { duration: 1.5, ease: "elastic.out", y: data.targetY });
                        }
                    }
                });

                // Listen for skull
                onValue(ref(this.db, 'game/shared/skull'), (snap) => {
                    const data = snap.val();
                    if (data) {
                        this.skull.position.set(data.position?.x || 0, data.position?.y || 0, data.position?.z || 0);
                        this.skull.visible = data.visible || false;
                        if (data.visible && data.position?.y === -1 && data.targetY !== undefined) {
                            this.skull.scale.set(0, 0, 0);
                            gsap.to(this.skull.scale, { duration: 1.5, ease: "elastic.out", x: 1, y: 1, z: 1 });
                            gsap.to(this.skull.position, { duration: 1.5, ease: "elastic.out", y: data.targetY });
                        }
                    }
                });
            }

            createFloor() {
                     
                this.floor = new Reflector(
                    new THREE.PlaneGeometry(this.floorSize, this.floorSize),
                    {
                        color: new THREE.Color(this.bgrColor),
                        textureWidth: 1024,
                        textureHeight: 1024
                    }
                )
                this.floor.rotation.x = -Math.PI / 2;
                this.floor.receiveShadow = true;
                this.modifyFloorShader();
               
                this.scene.add(this.floor);
            }
            createLine() {
                const material = new THREE.LineDashedMaterial({
                    color: 0x7beeff,
                    linewidth: 1,
                    scale: 1,
                    dashSize: 0.2,
                    gapSize: 0.1
                });
                const points = [];
                points.push(new THREE.Vector3(0, 0.2, 0));
                points.push(new THREE.Vector3(3, 0.2, 3));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                this.line = new THREE.Line(geometry, material);
                this.scene.add(this.line);
            }
         
            createParticles(){
                let bodyCount = 20;
                let tailCount =5;
                let particleGeom = new THREE.BoxGeometry(.2,.2,.2,1,1,1);
                this.particles1 = [];
                this.particles2 = [];
                let i = 0;
                for ( i=0; i< bodyCount; i++){
                    let m = new THREE.Mesh(particleGeom, this.bonusMat);
                    this.particles1.push(m)
                    m.scale.set(0,0,0);
                    this.scene.add(m);
                }
               
                for ( i=0; i< tailCount; i++){
                    let m = new THREE.Mesh(particleGeom, this.primMat1);
                    this.particles2.push(m)
                    m.scale.set(0,0,0);
                    this.scene.add(m);
                }
            }
            createLight() {
                this.ambientLight = new THREE.AmbientLight(0xffffff);
                this.scene.add(this.ambientLight);
                this.light = new THREE.DirectionalLight(0xffffff, 1);
                this.light.position.set(1, 5, 1);
                this.light.castShadow = true;
                this.light.shadow.mapSize.width = 512;
                this.light.shadow.mapSize.height = 512;
                this.light.shadow.camera.near = 0.5;
                this.light.shadow.camera.far = 12;
                this.light.shadow.camera.left = -12;
                this.light.shadow.camera.right = 12;
                this.light.shadow.camera.bottom = -12;
                this.light.shadow.camera.top = 12;
                this.light.shadow.radius = 3;
                this.light.shadow.blurSamples = 4;
                this.scene.add(this.light);
                const helper = new THREE.CameraHelper(this.light.shadow.camera);
                //this.scene.add(helper);
            }
            createRenderer() {
                const canvas = document.querySelector("canvas.webgl");
                this.renderer = new THREE.WebGLRenderer({
                    canvas,
                    antialias: true,
                    preserveDrawingBuffer: true
                });
                this.renderer.setClearColor(new THREE.Color(this.bgrColor))
                this.renderer.setPixelRatio((this.pixelRatio = window.devicePixelRatio));
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.toneMapping = THREE.LinearToneMapping;
                this.renderer.toneMappingExposure = 1;
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.VSMShadowMap;
                this.renderer.localClippingEnabled = true;
            }
         
            createSim(){
                const fragmentShader = document.getElementById('simulationFragmentShader').textContent;
                const vertexShader = document.getElementById('simulationVertexShader').textContent;
               
                this.floorSimMat = new THREE.ShaderMaterial({
                    uniforms: {
                        inputTexture: {type: "t", value: null},
                        time: { value: 0.0 },
                        blade1PosOld: {value: new THREE.Vector2(.5,.5)},
                        blade1PosNew: {value: new THREE.Vector2(.5,.5)},
                        strength: {value: 0.0},
                    },
                    vertexShader,
                    fragmentShader,
                })
                this.bufferSim = new BufferSim(this.renderer, 1024, 1024, this.floorSimMat)
            }
         
            createMaterials(){
                // Materials for player 1
                this.primMat1 = new THREE.MeshToonMaterial({ color: 0x7beeff });
                this.secMat1 = new THREE.MeshToonMaterial({ color: this.bgrColor });
                // Materials for player 2
                this.primMat2 = new THREE.MeshToonMaterial({ color: 0xff3434 });
                this.secMat2 = new THREE.MeshToonMaterial({ color: 0x000000 });
                // Shared
                this.bonusMat = new THREE.MeshToonMaterial({ color: 0xff3434 });
               
                // outline Material
                const fragmentShader = document.getElementById('outlineFragmentShader').textContent;
                const vertexShader = document.getElementById('outlineVertexShader').textContent;
                this.outlineMat = new THREE.ShaderMaterial({
                    uniforms : {
                        color: { value: new THREE.Color(0x000000) },
                        size: {type:"f", value:.02},
                    },
                    vertexShader,
                    fragmentShader,
                    side:THREE.BackSide,
                })
            }
         
            createControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.minDistance = 0;
                this.controls.maxDistance = 20;
                this.controls.enabled = true;
            }
            createListeners() {
                window.addEventListener("resize", this.onWindowResize.bind(this));
                document.addEventListener("mousemove", this.onMouseMove.bind(this), false);
                document.addEventListener("touchmove", this.onTouchMove.bind(this), false);
                document.addEventListener("mousedown", this.onMouseDown.bind(this), false);
            }
            draw() {
                this.updateGame();
                this.renderer.render(this.scene, this.camera);
                if (this.controls) this.controls.update();
                window.requestAnimationFrame(this.draw.bind(this));
            }
            updateGame() {
                if (this.gameState !== 'playing') return;
                this.dt = Math.min(this.clock.getDelta(), 0.3);
                this.time += this.dt;
                if (this.rabbit && this.line) {
                    const currentTime = Date.now() / 1000;
                    if (!this.skull.visible && currentTime > this.nextSkullSpawn) {
                        this.spawnSkull();
                        const newNext = currentTime + 3 + Math.random() * 5;
                        set(ref(this.db, 'game/shared/nextSkullSpawn'), newNext);
                    }
                    if (this.isUncontrolled && this.time < this.uncontrolledEndTime) {
                        // Lose control: no acceleration, but keep moving with friction
                        this.targetHeroUVPos.copy(this.heroNewUVPos);
                        this.heroSpeed.x *= 0.98; // Slight friction
                        this.heroSpeed.y *= 0.98;
                        this.rabbit.position.x += this.heroSpeed.x * this.dt;
                        this.rabbit.position.z += this.heroSpeed.y * this.dt;
                    } else if (this.isUncontrolled) {
                        this.isUncontrolled = false;
                    } else {
                        // Normal control
                        let accelMultiplier = 0.5 / this.level;
                        let constrainUVPosX = this.constrain(this.targetHeroUVPos.x - 0.5, -0.3, 0.3);
                        let constrainUVPosY = this.constrain(this.targetHeroUVPos.y - 0.5, -0.3, 0.3);
                        this.targetHeroAbsMousePos.x = constrainUVPosX * this.floorSize;
                        this.targetHeroAbsMousePos.y = -constrainUVPosY * this.floorSize;
                        let dx = this.targetHeroAbsMousePos.x - this.rabbit.position.x;
                        let dy = this.targetHeroAbsMousePos.y - this.rabbit.position.z;
                        let angle = Math.atan2(dy, dx);
                        this.heroDistance = Math.sqrt(dx * dx + dy * dy);
                        let ax = dx * this.dt * accelMultiplier;
                        let ay = dy * this.dt * accelMultiplier;
                        this.heroSpeed.x += ax;
                        this.heroSpeed.y += ay;
                        this.heroSpeed.x *= Math.pow(this.dt, 0.005);
                        this.heroSpeed.y *= Math.pow(this.dt, 0.005);
                        this.rabbit.position.x += this.heroSpeed.x;
                        this.rabbit.position.z += this.heroSpeed.y;
                        let targetRot = -angle + Math.PI / 2;
                        if (this.heroDistance > 0.3)
                            this.rabbit.rotation.y += this.getShortestAngle(targetRot - this.rabbit.rotation.y) * 3 * this.dt;
                        this.heroAngularSpeed = this.getShortestAngle( this.rabbit.rotation.y - this.heroOldRot);
                        this.heroOldRot = this.rabbit.rotation.y;
                        if (!this.isJumping){
                            this.earLeft.rotation.x = this.earRight.rotation.x = -this.heroSpeed.length() * 2;
                        }
                    }
                       
                    let p = this.line.geometry.attributes.position.array;
                    p[0] = this.targetHeroAbsMousePos.x;
                    p[2] = this.targetHeroAbsMousePos.y;
                    p[3] = this.rabbit.position.x;
                    p[4] = this.rabbit.position.y;
                    p[5] = this.rabbit.position.z;
                    this.line.geometry.attributes.position.needsUpdate = true;
                    this.line.computeLineDistances();
                 
                    this.heroNewUVPos = new THREE.Vector2(
                        0.5 + this.rabbit.position.x / this.floorSize,
                        0.5 - this.rabbit.position.z / this.floorSize
                    );
                 
                    let strength = this.isJumping
                        ? 0
                        : 1 / (1 + this.heroSpeed.length() * 10);
                    if (this.isUncontrolled) strength = 0;
                    this.floorSimMat.time += this.dt;
                    this.floorSimMat.uniforms.blade1PosNew.value = this.heroNewUVPos;
                    this.floorSimMat.uniforms.blade1PosOld.value = this.heroOldUVPos;
                    this.floorSimMat.uniforms.strength.value = strength;
                    this.bufferSim.render();
                    this.renderer.setRenderTarget(null);
                    this.floor.material.uniforms.tScratches.value = this.bufferSim.output.texture;
                    this.heroOldUVPos = this.heroNewUVPos.clone();
                    this.carrot.rotation.y += this.dt;
                    this.skull.rotation.y += this.dt;
                    this.testCollision();

                    // Sync position and rotation
                    const now = Date.now();
                    if (now - this.lastSync > 50) {
                        set(ref(this.db, `game/players/${this.playerId}/position`), {
                            x: this.rabbit.position.x,
                            y: this.rabbit.position.y,
                            z: this.rabbit.position.z
                        });
                        set(ref(this.db, `game/players/${this.playerId}/rotation`), {
                            x: this.rabbit.rotation.x,
                            y: this.rabbit.rotation.y,
                            z: this.rabbit.rotation.z
                        });
                        this.lastSync = now;
                    }
                }
            }
            onWindowResize() {
                this.winWidth = window.innerWidth;
                this.winHeight = window.innerHeight;
                this.camera.aspect = this.winWidth / this.winHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.winWidth, this.winHeight);
            }
            onMouseMove(event) {
                const x = event.clientX / this.winWidth * 2 - 1;
                const y = -(event.clientY / this.winHeight * 2 - 1);
                this.mouse.x = x;
                this.mouse.y = y;
                if (this.floor && !this.isUncontrolled && this.gameState === 'playing') this.raycast();
            }
         
            onTouchMove(event) {
                if (event.touches.length == 1) {
                    event.preventDefault();
                    const x = event.touches[0].pageX / this.winWidth * 2 - 1;
                    const y = -(event.touches[0].pageY / this.winHeight * 2 - 1);
                    this.mouse.x = x;
                    this.mouse.y = y;
                    if (this.floor && !this.isUncontrolled && this.gameState === 'playing') this.raycast();
                }
            }
         
            onMouseDown(){
                if (this.rabbit && !this.isJumping && this.gameState === 'playing') this.jump();
            }
         
            jump() {
                this.jumpSound.play().catch(e => console.log('Error al reproducir sonido:', e));
                this.isJumping = true;
                let turns = Math.floor(this.heroSpeed.length() * 5) + 1;
                let jumpDuration = .5 + turns * .2;
                let targetRot = (this.heroAngularSpeed>0)? Math.PI*2*turns : -Math.PI*2*turns
                   
                gsap.to(this.rabbitBody.rotation, {
                    duration: jumpDuration,
                    ease: "linear.none",
                    y: targetRot,
                    onComplete: ()=>{
                        this.rabbitBody.rotation.y = 0;
                    }
                });
                gsap.to([this.earLeft.rotation, this.earRight.rotation], {
                    duration: jumpDuration * .8,
                    ease: "power4.out",
                    x: Math.PI/4,
                });
                gsap.to([this.earLeft.rotation, this.earRight.rotation], {
                    duration: jumpDuration * .2,
                    delay: jumpDuration * .8,
                    ease: "power4.in",
                    x: 0,
                });
                gsap.to(this.jumpParams, {
                    duration: jumpDuration * .5,
                    ease : "power2.out",
                    jumpProgress:.5,
                    onUpdate: () => {
                        let sin = Math.sin( this.jumpParams.jumpProgress * Math.PI) ;
                        this.rabbit.position.y = Math.pow(sin, 4) * turns;
                    }
                });
                gsap.to(this.jumpParams, {
                    duration: jumpDuration * .5,
                    ease : "power2.in",
                    delay : jumpDuration * .5,
                    jumpProgress:1,
                    onUpdate: () => {
                        let sin = Math.sin( this.jumpParams.jumpProgress * Math.PI) ;
                        this.rabbit.position.y = Math.pow(sin, 1) * turns;
                    },
                    onComplete: () => {
                        this.rabbit.position.y = 0;
                        this.jumpParams.jumpProgress = 0;
                        this.isJumping = false;
                    }
                });
            }
         
            raycast() {
                this.raycaster.setFromCamera( this.mouse, this.camera );
                var intersects = this.raycaster.intersectObjects( [this.floor] );
                if (intersects.length>0){
                    this.targetHeroUVPos.x = intersects[0].uv.x;
                    this.targetHeroUVPos.y = intersects[0].uv.y;
                }
            }
            getShortestAngle(v) {
                let a = v % (Math.PI * 2);
                if (a < -Math.PI) a += Math.PI * 2;
                else if (a > Math.PI) a -= Math.PI * 2;
                return a;
            }
            constrain(v, vMin, vMax) {
                return Math.min(vMax, Math.max(vMin, v));
            }
         
            testCollision(){
                if (this.isExploding) return;
                let distVec = this.rabbit.position.clone();
                distVec.sub(this.carrot.position);
                let l = distVec.length();
                if (l <= 1 && this.carrot.visible){
                    this.carrotSound.play().catch(e => console.log('Error al reproducir sonido:', e));
                    set(ref(this.db, 'game/shared/carrot'), {visible: false});
                    this.score++;
                    if (this.score % 5 === 0) {
                        this.level++;
                    }
                    this.updateScore();
                    this.flashYellow();
                    const pos = this.carrot.position.clone();
                    this.explode(pos);
                }

                let distVecSkull = this.rabbit.position.clone();
                distVecSkull.sub(this.skull.position);
                let lSkull = distVecSkull.length();
                if (lSkull <= 1 && this.skull.visible){
                    set(ref(this.db, 'game/shared/skull'), {visible: false});
                    this.flashGreenAndUncontrol();
                }
            }

            flashYellow() {
                const normalColor = { r: this.playerId === 1 ? 123/255 : 1, g: this.playerId === 1 ? 238/255 : 0.2, b: this.playerId === 1 ? 255/255 : 0.2 };
                const yellowColor = { r: 1, g: 1, b: 0 };
                const primMat = this.playerId === 1 ? this.primMat1 : this.primMat2;
                primMat.color.setRGB(1,1,0);
                const tl = gsap.timeline({
                    onComplete: () => {
                        primMat.color.setRGB(normalColor.r, normalColor.g, normalColor.b);
                    }
                });
                tl.to({}, {duration: 0.7});
                tl.to(primMat.color, {
                    r: normalColor.r,
                    g: normalColor.g,
                    b: normalColor.b,
                    duration: 0.1,
                    repeat: 3,
                    yoyo: true,
                    ease: "none"
                });
            }

            flashGreenAndUncontrol() {
                const normalColor = { r: this.playerId === 1 ? 123/255 : 1, g: this.playerId === 1 ? 238/255 : 0.2, b: this.playerId === 1 ? 255/255 : 0.2 };
                const greenColor = { r: 0, g: 1, b: 0 };
                const primMat = this.playerId === 1 ? this.primMat1 : this.primMat2;
                primMat.color.setRGB(0,1,0);
                this.isUncontrolled = true;
                this.uncontrolledEndTime = this.time + 2;
                const tl = gsap.timeline({
                    onComplete: () => {
                        this.isUncontrolled = false;
                        primMat.color.setRGB(normalColor.r, normalColor.g, normalColor.b);
                    }
                });
                tl.to({}, {duration: 1.5});
                tl.to(primMat.color, {
                    r: normalColor.r,
                    g: normalColor.g,
                    b: normalColor.b,
                    duration: 0.1,
                    repeat: 5,
                    yoyo: true,
                    ease: "none"
                });
            }
         
            explode(pos){
                this.isExploding = true;
                let p1Count = this.particles1.length;
                let p2Count = this.particles2.length;
                let i = 0;
                let completeCount = 0;
                let totalParticles = p1Count + p2Count;
                for ( i=0; i< p1Count; i++){
                    let m = this.particles1[i];
                    m.position.x = pos.x;
                    m.position.y = pos.y;
                    m.position.z = pos.z;
                    m.scale.set(2,2,2);
                    gsap.to(m.position, {
                        x: pos.x + (-.5 + Math.random()) * 1.5,
                        y: pos.y + (.5 + Math.random()) * 1.5,
                        z: pos.z + (-.5 + Math.random()) * 1.5,
                        duration : 1,
                        ease: "power4.out",
                    })
                    gsap.to(m.scale, {
                        x:0,
                        y:0,
                        z:0,
                        duration : 1,
                        ease: "power4.out",
                        onComplete: ()=>{
                            completeCount++;
                            if (completeCount >= totalParticles) {
                                this.spawnCarrot();
                                this.isExploding = false;
                            }
                        }
                    })
                }
                for ( i=0; i< p2Count; i++){
                    let m = this.particles2[i];
                    m.position.x = pos.x;
                    m.position.y = pos.y;
                    m.position.z = pos.z;
                    m.scale.set(2,2,2);
                    gsap.to(m.position, {
                        x: pos.x + (-.5 + Math.random()) * 1.5,
                        y: pos.y + (.5 + Math.random()) * 1.5,
                        z: pos.z + (-.5 + Math.random()) * 1.5,
                        duration : 1,
                        ease: "power4.out",
                    })
                    gsap.to(m.scale, {
                        x:0,
                        y:0,
                        z:0,
                        duration : 1,
                        ease: "power4.out",
                        onComplete: ()=>{
                            completeCount++;
                            if (completeCount >= totalParticles) {
                                this.spawnCarrot();
                                this.isExploding = false;
                            }
                        }
                    })
                }
            }
         
            spawnCarrot(){
                let maxOffset = 8;
                let px = (Math.random() - 0.5) * 2 * maxOffset;
                let pz = (Math.random() - 0.5) * 2 * maxOffset;
                let h = .2 + Math.random() * 1;
                set(ref(this.db, 'game/shared/carrot'), {
                    position: {x: px, y: -1, z: pz},
                    visible: true,
                    targetY: h
                });
            }

            spawnSkull() {
                let maxOffset = 8;
                let px = (Math.random() - 0.5) * 2 * maxOffset;
                let pz = (Math.random() - 0.5) * 2 * maxOffset;
                let h = 0.2 + Math.random();
                set(ref(this.db, 'game/shared/skull'), {
                    position: {x: px, y: -1, z: pz},
                    visible: true,
                    targetY: h
                });
            }
         
            modifyFloorShader(){
               
                // the floor is currently a Reflector which reacts as a mirror
                // in order to make it a bit more interesting (adding blur, displacement and shadows)
                // we will supercharge its shaders with custom code.
               
                // get the renderTarget and texture Matrix from the unaltered reflector
                let renderTarget = this.floor.getRenderTarget();
                const textureMatrix = this.floor.material.uniforms.textureMatrix;
               
                // get the custom shaders
                const fragmentShader = document.getElementById('reflectorFragmentShader').textContent;
                const vertexShader = document.getElementById('reflectorVertexShader').textContent;
               
                // merge the uniforms of the reflector with additional shadow and light uniforms
                const uniforms = THREE.UniformsUtils.merge([
                    THREE.UniformsLib['common'],
                    THREE.UniformsLib['shadowmap'],
                    THREE.UniformsLib['lights'],
                    this.floor.material.uniforms,
                    {
                        tScratches : { value: this.bufferSim.output.texture },
                }
                ])
         
                // apply to the reflector
                this.floor.material.lights = true;
                this.floor.material.uniforms = uniforms;
                this.floor.material.uniforms.tDiffuse.value = renderTarget.texture;
                this.floor.material.uniforms.textureMatrix.value = textureMatrix.value;
                this.floor.material.vertexShader = vertexShader;
                this.floor.material.fragmentShader = fragmentShader;
            }
        }
        class BufferSim{
            constructor ( renderer, width, height, shader ) {
                this.renderer = renderer;
                this.shader = shader;
                this.orthoScene = new THREE.Scene();
                var fbo = new THREE.WebGLRenderTarget( width, height, {
                    wrapS: THREE.ClampToEdgeWrapping,
                    wrapT: THREE.ClampToEdgeWrapping,
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType,
                    stencilBuffer: false,
                    depthBuffer: false
                });
                fbo.texture.generateMipmaps = false;
               
                this.fbos = [ fbo, fbo.clone() ];
                this.current = 0;
                this.output = this.fbos[ 0 ];
                this.orthoCamera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, .00001, 1000 );
                this.orthoQuad = new THREE.Mesh( new THREE.PlaneGeometry( width, height ), this.shader );
                this.orthoScene.add( this.orthoQuad );
            }
            render(){
                this.shader.uniforms.inputTexture.value = this.fbos[ this.current ].texture;
                this.input = this.fbos[ this.current ];
                this.current = 1 - this.current;
                this.output = this.fbos[ this.current ];
                this.renderer.setRenderTarget(this.output);
                this.renderer.render( this.orthoScene, this.orthoCamera );
                this.renderer.setRenderTarget(null);
            }
        }
    </script>
</body>
</html>
